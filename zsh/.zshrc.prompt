setopt PROMPT_SUBST

autoload -U colors && colors

black="%{$fg_bold[black]%}"
gray="%{$fg[white]%}"
grey="%{$fg[white]%}"
red="%{$fg_bold[red]%}"
d_green="%{$fg[green]%}"
green="%{$fg_bold[green]%}"
yellow="%{$fg_bold[yellow]%}"
blue="%{$fg_bold[blue]%}"
purple="%{$fg_bold[magenta]%}"
magenta="%{$fg_bold[magenta]%}"
cyan="%{$fg_bold[cyan]%}"
white="%{$fg_bold[white]%}"
end="%{$reset_color%}"

last_cmd_succ="%(?.${black}.${red})|${end}"

function dir_stacks () {
    depth=$(dirs -p | wc -l | tr -d ' ')
    if [[ $depth -gt 1 ]]; then
        dir_stack_str=$(printf '%*s' ${depth} | tr ' ' '[')
        echo "${d_green}${dir_stack_str:1}"

    fi
}

function current_path () {
    echo "$(dir_stacks)${green}[%~]${end}"
}

is_git_installed=$(command -v git)
if [[ $? -eq 0 ]]; then
    # Oh yes, we really have git
    function git_branch_name () {

        branch_name=$(git rev-parse --abbrev-ref HEAD 2>/dev/null)
        if [[ -n $branch_name ]]; then
            # we are now in a git repo
            git_root=$(git rev-parse --show-toplevel 2>/dev/null)

            if [[ -f $git_root/.git/refs/stash ]]; then
                stashes_count=$(git stash list 2>/dev/null | wc -l | tr -d ' ')
                stashes_stack_str=$(printf '%*s' ${stashes_count} | tr ' ' ')')
            fi

            is_bare=$(git rev-parse --is-bare-repository 2>/dev/null)
            if [[ "$is_bare" == "true" ]]; then
                # this repo is bare
                echo "${blue}(=BARE=)${stashes_stack_str}${end}"

            elif [[ -z $(git status --porcelain 2>/dev/null) ]]; then
                # This repo is clean
                echo "${blue}(${branch_name})${stashes_stack_str}${end}"

            elif [[ -z $(git status -s -uno 2>/dev/null) ]]; then
                # This repo is dirty, but no modify on tracked files
                echo "${purple}(${branch_name})${stashes_stack_str}${end}"

            else
                # This repo is dirty, and there are changes had been staged
                echo "${red}(${branch_name})${stashes_stack_str}${end}"

            fi

        fi
    }
else
    function git_branch_name () {}
fi

suspend_jobs="%1(j.${blue}jobs:%j${end}.)"

vim_mode_str="${black}[zsh]${end}"

function zle-line-finish {
    vim_mode_str="${black}[zsh]${end}"
}

function zle-keymap-select {
    case ${KEYMAP} in
    vicmd)
        vim_mode_str="${cyan}:zsh:${end}"
        ;;

    viins|main)
        vim_mode_str="${black}[zsh]${end}"
        ;;

    esac
    zle reset-prompt

}
zle -N zle-line-finish
zle -N zle-keymap-select

time_str="${cyan}%T${end}"
user_name_str="${yellow}%n${end}"
at_str="${gray}@${end}"
host_name_str="${white}%m${end}"

screen_str=""
if [[ "$TERM" == 'screen'* ]]; then
    if [[ -n "$TMUX" ]]; then
        session_name=`tmux display-message -p '#S'`
        WINDOW=`tmux display-message -p '#I'`
        screen_str="%{[1;35m[$session_name T$WINDOW][m%}"

    elif [[ -n "$STY" ]]; then
        session_name="`echo $STY | cut -d '.' -f2`"
        screen_str="%{[1;35m[$session_name S$WINDOW][m%}"

    fi
fi

uid_str="%(!.#.>)"

prompt='${last_cmd_succ}$(current_path)$(git_branch_name)${suspend_jobs}${vim_mode_str}
${last_cmd_succ}${time_str}${user_name_str}${at_str}${host_name_str}${screen_str}${uid_str} '

