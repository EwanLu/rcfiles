setopt PROMPT_SUBST

autoload -U colors && colors

black="%{$fg_bold[black]%}"
gray="%{$fg[white]%}"
grey=$gray
red="%{$fg_bold[red]%}"
d_green="%{$fg[green]%}"
green="%{$fg_bold[green]%}"
yellow="%{$fg_bold[yellow]%}"
blue="%{$fg_bold[blue]%}"
purple="%{$fg_bold[magenta]%}"
magenta=$purple
cyan="%{$fg_bold[cyan]%}"
white="%{$fg_bold[white]%}"
end="%{$reset_color%}"

last_cmd_succ="%(?.${black}.${red})|${end}"

function _dir_stacks {
    depth=$(dirs -p | wc -l | tr -d ' ')
    if [[ $depth -gt 1 ]]; then
        dir_stack_str=$(printf '%*s' ${depth} | tr ' ' '[')
        echo "${d_green}${dir_stack_str:1}"

    fi
}

function _current_path {
    echo "$(_dir_stacks)${green}[%~]${end}"
}

if [[ -n "$(command -v git)" ]]; then
    # Oh yes, we really have git
    function _git_branch_name () {

        local branch_name=$(git rev-parse --abbrev-ref HEAD 2>/dev/null)
        if [[ -n $branch_name ]]; then
            # we are now in a git repo
            local git_root=$(git rev-parse --show-toplevel 2>/dev/null)

            if [[ -f $git_root/.git/refs/stash ]]; then
                local stashes_count=$(git stash list 2>/dev/null | wc -l | tr -d ' ')
                local stashes_stack_str=$(printf '%*s' ${stashes_count} | tr ' ' ')')
            fi

            local is_bare=$(git rev-parse --is-bare-repository 2>/dev/null)
            if [[ "$is_bare" == "true" ]]; then
                # this repo is bare
                echo "${blue}(=BARE=)${stashes_stack_str}${end}"

            elif [[ -z $(git status --porcelain 2>/dev/null) ]]; then
                # This repo is clean
                echo "${blue}(${branch_name})${stashes_stack_str}${end}"

            elif [[ -z $(git status -s -uno 2>/dev/null) ]]; then
                # This repo is dirty, but no modify on tracked files
                echo "${purple}(${branch_name})${stashes_stack_str}${end}"

            else
                # This repo is dirty, and there are changes had been staged
                echo "${red}(${branch_name})${stashes_stack_str}${end}"

            fi

        fi
    }
else
    function _git_branch_name () {}
fi

suspend_jobs="%1(j.${blue}jobs:%j${end}.)"

vim_mode_str="${black}[zsh]${end}"

time_str="${cyan}%T${end}"
user_name_str="${yellow}%n${end}"
at_str="${gray}@${end}"
host_name_str="${white}%m${end}"
uid_str="%(!.#.>)"

function _set_prompt {
    case ${KEYMAP} in
        vicmd)      local vim_mode_str="${cyan}:zsh$ZSH_VERSION:${end}" ;;
        viins|main) local vim_mode_str="${black}[zsh$ZSH_VERSION]${end}" ;;
    esac

    prompt="${last_cmd_succ}$(_current_path)$(_git_branch_name)${suspend_jobs}${vim_mode_str}
${last_cmd_succ}${time_str}${user_name_str}${at_str}${host_name_str}${uid_str} "
    if [[ -n $VIRTUAL_ENV ]]; then
        prompt="${last_cmd_succ}${blue}(${VIRTUAL_ENV##*/})${end}
${prompt}"
    fi
}

function zle-keymap-select zle-line-finish zle-line-init {
    _set_prompt
    zle reset-prompt
}
zle -N zle-line-finish
zle -N zle-keymap-select
zle -N zle-line-init

_set_prompt
